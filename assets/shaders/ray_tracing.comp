#version 450

layout(local_size_x = 16, local_size_y = 16) in;
layout(set = 0, binding = 0, rgba8) uniform writeonly image2D resultImage;

#define PI 3.1415926
#define FLT_MAX 3.402823466e+38
#define NUM_SAMPLES 100
#define NUM_BOUNCES 50
#define ANTI_ALIASING_FORCE 0.003
#define BACKGROUND_COLOR vec3(0.7, 0.8, 1.0)

uint rngState = (600 * gl_GlobalInvocationID.x + gl_GlobalInvocationID.y);

#define TEXTURE_TYPE_SOLID 0
#define TEXTURE_TYPE_CHECKER 1

struct Texture {
  int type;
  vec3 color;
  float invScale;
  vec3 evenColor;
  vec3 oddColor;
};

vec3 textureValue(Texture texture, float u, float v, vec3 point);

struct Ray {
  vec3 origin;
  vec3 dir;
};

vec3 rayAt(Ray ray, float t);

#define MATERIAL_TYPE_LAMBEERTIAN 0
#define MATERIAL_TYPE_METAL 1
#define MATERIAL_TYPE_DIELECTRIC 2
#define MATERIAL_TYPE_DIFFUSE_LIGHT 3

struct Material {
  int type;
  vec3 albedo;
  float fuzz;
  float ir;
  bool textured;
  Texture texture;
};

struct HitRecord {
  vec3 point;
  vec3 normal;
  float t;
  bool frontFace;
  Material material;
  float u;
  float v;
};

void hitRecordSetFaceNormal(inout HitRecord hitRecord, Ray ray,
                            vec3 outwardNormal);
bool isInterior(float a, float b, inout HitRecord hitRecord);

float reflectance(float cosine, float refIdx);
bool materialScatter(Material material, Ray ray, HitRecord record,
                     inout vec3 attenuation, inout Ray scattered);
vec3 materialEmitted(Material material, float u, float v, vec3 point);

struct Interval {
  float min;
  float max;
};

bool intervalContains(Interval interval, float x);
bool intervalSurrounds(Interval interval, float x);
float intervalClamp(Interval interval, float x);

#define NUM_SPHERES 1

struct Sphere {
  vec3 center;
  float radius;
  Material material;
};

bool sphereHit(Sphere sphere, Ray ray, Interval interval,
               inout HitRecord hitRecord);
void sphereGetUV(vec3 point, inout float u, inout float v);

#define NUM_QUADS 6

struct Quad {
  vec3 q;
  vec3 u;
  vec3 v;
  Material material;
};

bool quadHit(Quad quad, Ray ray, Interval interval, inout HitRecord hitRecord);

float lengthSquared(vec3 vector);
float degreesToRadians(float degrees);
float linearToGamma(float linearComponent);
bool nearZero(vec3 vec);

uint stepRNG(uint rngState);
float stepAndOutputRNGFloat(inout uint rngState);
float randomFloat();
float randomFloat(float min, float max);
vec3 randomVector();
vec3 randomVector(float min, float max);
vec3 randomInUnitSphere();
vec3 randomUnitVector();
vec3 randomOnHemisphere(vec3 normal);

bool worldHit(Ray ray, Interval interval, inout HitRecord hitRecord);
vec3 rayColor(Ray ray);

/* +1 so that if NUM_SPHERES == 0 there will be no compilation errors */
Sphere spheres[NUM_SPHERES + 1];
Quad quads[NUM_QUADS];

void main() {
  /* TODO: add camera controller (+ defocus blur) + bvh */
  const vec3 camPos = vec3(278.0, 278.0, 555.0);

  Material red;
  red.type = MATERIAL_TYPE_LAMBEERTIAN;
  red.albedo = vec3(0.65, 0.05, 0.05);
  Material white;
  white.type = MATERIAL_TYPE_LAMBEERTIAN;
  white.albedo = vec3(0.73);
  Material green;
  green.type = MATERIAL_TYPE_LAMBEERTIAN;
  green.albedo = vec3(0.12, 0.45, 0.15);
  Material light;
  light.type = MATERIAL_TYPE_DIFFUSE_LIGHT;
  light.textured = true;
  light.texture.type = TEXTURE_TYPE_SOLID;
  light.texture.color = vec3(15);

  int index = 0;
  quads[index].q = vec3(555, 0, 0);
  quads[index].u = vec3(0, 555, 0);
  quads[index].v = vec3(0, 0, 555);
  quads[index].material = green;

  index = 1;
  quads[index].q = vec3(0, 0, 0);
  quads[index].u = vec3(0, 555, 0);
  quads[index].v = vec3(0, 0, 555);
  quads[index].material = red;

  index = 2;
  quads[index].q = vec3(343, 554, 332);
  quads[index].u = vec3(-130, 0, 0);
  quads[index].v = vec3(0, 0, -105);
  quads[index].material = light;

  index = 3;
  quads[index].q = vec3(0, 0, 0);
  quads[index].u = vec3(555, 0, 0);
  quads[index].v = vec3(0, 0, 555);
  quads[index].material = white;

  index = 4;
  quads[index].q = vec3(555, 555, 555);
  quads[index].u = vec3(-555, 0, 0);
  quads[index].v = vec3(0, 0, -555);
  quads[index].material = white;

  index = 5;
  quads[index].q = vec3(0, 0, 0);
  quads[index].u = vec3(555, 0, 0);
  quads[index].v = vec3(0, 555, 0);
  quads[index].material = white;

  ivec2 imageSize = imageSize(resultImage);
  vec2 uv = vec2(gl_GlobalInvocationID.xy) / imageSize;

  float aspectRatio = float(imageSize.x) / float(imageSize.y);

  vec3 pixelColor = vec3(0.0);
  for (int i = 0; i < NUM_SAMPLES; ++i) {
    float px = randomFloat(-ANTI_ALIASING_FORCE, ANTI_ALIASING_FORCE);
    float py = randomFloat(-ANTI_ALIASING_FORCE, ANTI_ALIASING_FORCE);
    vec2 sampleSquare = (px * vec2(uv.x, 0.0)) + (py * vec2(0.0, uv.y));

    Ray ray = {camPos, normalize(vec3((-1.0 + 2.0 * (uv + sampleSquare)) *
                                          vec2(aspectRatio, 1.0),
                                      -1.0))};

    pixelColor += rayColor(ray);
  }

  pixelColor *= 1.0 / NUM_SAMPLES;
  pixelColor.x = linearToGamma(pixelColor.x);
  pixelColor.y = linearToGamma(pixelColor.y);
  pixelColor.z = linearToGamma(pixelColor.z);

  imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy),
             vec4(pixelColor, 1.0));
}

vec3 textureValue(Texture texture, float u, float v, vec3 point) {
  switch (texture.type) {
  case TEXTURE_TYPE_SOLID: {
    return texture.color;
  } break;
  case TEXTURE_TYPE_CHECKER: {
    int xInt = int(floor(texture.invScale * point.x));
    int yInt = int(floor(texture.invScale * point.y));
    int zInt = int(floor(texture.invScale * point.z));

    bool isEven = (xInt + yInt + zInt) % 2 == 0;

    return isEven ? texture.evenColor : texture.oddColor;

  } break;
  default: {
    return vec3(0.0);
  } break;
  }

  return vec3(0.0);
}

vec3 rayAt(Ray ray, float t) { return ray.origin + t * ray.dir; }

void hitRecordSetFaceNormal(inout HitRecord hitRecord, Ray ray,
                            vec3 outwardNormal) {
  hitRecord.frontFace = dot(ray.dir, outwardNormal) < 0;
  hitRecord.normal = hitRecord.frontFace ? outwardNormal : -outwardNormal;
}

bool isInterior(float a, float b, inout HitRecord hitRecord) {
  if ((a < 0) || (1 < a) || (b < 0) || (1 < b)) {
    return false;
  }

  hitRecord.u = a;
  hitRecord.v = b;
  return true;
}

float reflectance(float cosine, float refIdx) {
  float r0 = (1 - refIdx) / (1 + refIdx);
  r0 = r0 * r0;

  return r0 + (1 - r0) * pow(1 - cosine, 5);
}

bool materialScatter(Material material, Ray ray, HitRecord record,
                     inout vec3 attenuation, inout Ray scattered) {
  switch (material.type) {
  case MATERIAL_TYPE_LAMBEERTIAN: {
    vec3 scatterDirection = record.normal + randomUnitVector();
    if (nearZero(scatterDirection)) {
      scatterDirection = record.normal;
    }
    scattered.origin = record.point;
    scattered.dir = scatterDirection;
    if (material.textured) {
      attenuation =
          textureValue(material.texture, record.u, record.v, record.point);
    } else {
      attenuation = material.albedo;
    }

    return true;
  } break;
  case MATERIAL_TYPE_METAL: {
    vec3 reflected = reflect(normalize(ray.dir), record.normal);
    scattered.origin = record.point;
    scattered.dir = reflected + material.fuzz * randomUnitVector();
    attenuation = material.albedo;

    return dot(scattered.dir, record.normal) > 0;
  } break;
  case MATERIAL_TYPE_DIELECTRIC: {
    attenuation = vec3(1.0);
    float refractionRatio =
        record.frontFace ? (1.0 / material.ir) : material.ir;

    vec3 unitDirection = normalize(ray.dir);
    float cosTheta = min(dot(-unitDirection, record.normal), 1.0);
    float sinTheta = sqrt(1.0 - (cosTheta * cosTheta));

    bool cannotRefract = (refractionRatio * sinTheta) > 1.0;
    vec3 direction;
    if (cannotRefract ||
        reflectance(cosTheta, refractionRatio) > randomFloat()) {
      direction = reflect(unitDirection, record.normal);
    } else {
      direction = refract(unitDirection, record.normal, refractionRatio);
    }

    scattered.origin = record.point;
    scattered.dir = direction;

    return true;
  } break;
  case MATERIAL_TYPE_DIFFUSE_LIGHT: {
    return false;
  } break;
  default: {
    return false;
  } break;
  }

  return false;
}

vec3 materialEmitted(Material material, float u, float v, vec3 point) {
  switch (material.type) {
  case MATERIAL_TYPE_DIFFUSE_LIGHT: {
    return textureValue(material.texture, u, v, point);
  } break;
  default: {
    return vec3(0.0);
  } break;
  }
  return vec3(0.0);
}

bool intervalContains(Interval interval, float x) {
  return interval.min <= x && x <= interval.max;
}

bool intervalSurrounds(Interval interval, float x) {
  return interval.min < x && x < interval.max;
}

float intervalClamp(Interval interval, float x) {
  return clamp(x, interval.min, interval.max);
}

bool sphereHit(Sphere sphere, Ray ray, Interval interval,
               inout HitRecord hitRecord) {
  vec3 oc = ray.origin - sphere.center;
  float a = dot(ray.dir, ray.dir);
  float halfB = dot(oc, ray.dir);
  float c = dot(oc, oc) - sphere.radius * sphere.radius;

  float discriminant = halfB * halfB - a * c;
  if (discriminant < 0.0) {
    return false;
  }

  float sqrtd = sqrt(discriminant);

  float root = (-halfB - sqrtd) / a;
  if (!intervalSurrounds(interval, root)) {
    root = (-halfB + sqrtd) / a;
    if (!intervalSurrounds(interval, root)) {
      return false;
    }
  }

  hitRecord.t = root;
  hitRecord.point = rayAt(ray, hitRecord.t);
  vec3 outwardNormal = (hitRecord.point - sphere.center) / sphere.radius;
  sphereGetUV(outwardNormal, hitRecord.u, hitRecord.v);
  hitRecordSetFaceNormal(hitRecord, ray, outwardNormal);
  hitRecord.material = sphere.material;

  return true;
}

bool quadHit(Quad quad, Ray ray, Interval interval, inout HitRecord hitRecord) {
  vec3 n = cross(quad.u, quad.v);

  vec3 normal = normalize(n);
  float d = dot(normal, quad.q);
  vec3 w = n / dot(n, n);

  float denom = dot(normal, ray.dir);

  if (abs(denom) < 1e-8) {
    return false;
  }

  float t = (d - dot(normal, ray.origin)) / denom;
  if (!intervalContains(interval, t)) {
    return false;
  }

  vec3 intersection = rayAt(ray, t);
  vec3 planarHitptVector = intersection - quad.q;
  float alpha = dot(w, cross(planarHitptVector, quad.v));
  float beta = dot(w, cross(quad.u, planarHitptVector));

  if (!isInterior(alpha, beta, hitRecord)) {
    return false;
  }

  hitRecord.t = t;
  hitRecord.point = intersection;
  hitRecord.material = quad.material;
  hitRecordSetFaceNormal(hitRecord, ray, normal);

  return true;
}

void sphereGetUV(vec3 point, inout float u, inout float v) {
  float theta = acos(-point.y);
  float phi = atan(point.x, -point.z) + PI;

  u = phi / (2 * PI);
  v = theta / PI;
}

float lengthSquared(vec3 vector) {
  return vector.x * vector.x + vector.y * vector.y + vector.z * vector.z;
}

float degreesToRadians(float degrees) { return degrees * PI / 180.0; }

float linearToGamma(float linearComponent) { return sqrt(linearComponent); }

bool nearZero(vec3 vec) {
  float s = 1e-8;
  return abs(vec.x) < s && abs(vec.y) < s && abs(vec.z) < s;
}

uint stepRNG(uint rngState) { return rngState * 747796405 + 1; }

float stepAndOutputRNGFloat(inout uint rngState) {
  rngState = stepRNG(rngState);
  uint word = ((rngState >> ((rngState >> 28) + 4)) ^ rngState) * 277803737;
  word = (word >> 22) ^ word;
  return float(word) / 4294967295.0f;
}

float randomFloat() { return stepAndOutputRNGFloat(rngState); }

float randomFloat(float min, float max) {
  return min + (max - min) * randomFloat();
}

vec3 randomVector() {
  return vec3(randomFloat(), randomFloat(), randomFloat());
}

vec3 randomVector(float min, float max) {
  return vec3(randomFloat(min, max), randomFloat(min, max),
              randomFloat(min, max));
}

vec3 randomInUnitSphere() {
  while (true) {
    vec3 point = randomVector(-1, 1);
    if (lengthSquared(point) < 1) {
      return point;
    }
  }

  return vec3(0.0);
}

vec3 randomUnitVector() { return normalize(randomInUnitSphere()); }

vec3 randomOnHemisphere(vec3 normal) {
  vec3 onUnitSphere = randomUnitVector();
  int multiplier = int(dot(onUnitSphere, normal) > 0.0) * 2 - 1;

  return onUnitSphere * multiplier;
}

bool worldHit(Ray ray, Interval interval, inout HitRecord hitRecord) {
  HitRecord tempRecord;
  bool hitAnything = false;
  float closestSoFar = interval.max;

  for (int i = 0; i < NUM_SPHERES + NUM_QUADS; ++i) {
    Interval tempInterval = {interval.min, closestSoFar};
    if (i < NUM_SPHERES &&
        sphereHit(spheres[i], ray, tempInterval, tempRecord)) {
      hitAnything = true;
      closestSoFar = tempRecord.t;
      hitRecord = tempRecord;
    } else if (i < NUM_QUADS &&
               quadHit(quads[i], ray, tempInterval, tempRecord)) {
      hitAnything = true;
      closestSoFar = tempRecord.t;
      hitRecord = tempRecord;
    }
  }

  return hitAnything;
}

vec3 rayColor(Ray ray) {
  vec3 result = vec3(1.0);
  Interval interval = {0.001, FLT_MAX};
  Ray currentRay = ray;
  HitRecord record;

  for (int i = 0; i < NUM_BOUNCES; ++i) {
    if (worldHit(currentRay, interval, record)) {
      Ray scattered;
      vec3 attenuation;

      vec3 colorFromEmission =
          materialEmitted(record.material, record.u, record.v, record.point);

      if (!materialScatter(record.material, ray, record, attenuation,
                           scattered)) {
        return colorFromEmission * result;
      }

      result *= attenuation;
      currentRay = scattered;
    } else {
      return result * BACKGROUND_COLOR;
    }
  }

  return vec3(0.0);
}