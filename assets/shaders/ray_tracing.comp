#version 450

layout(local_size_x = 16, local_size_y = 16) in;
layout(set = 0, binding = 0, rgba8) uniform writeonly image2D resultImage;

#define PI 3.1415926
#define FLT_MAX 3.402823466e+38
#define NUM_SPHERES 4
#define NUM_SAMPLES 100
#define ANTI_ALIASING_FORCE 0.003
#define NUM_BOUNCES 50

uint rngState = (600 * gl_GlobalInvocationID.x + gl_GlobalInvocationID.y);

#define TEXTURE_TYPE_SOLID 0
#define TEXTURE_TYPE_CHECKER 1

struct Texture {
  int type;
  vec3 color;
  float invScale;
  vec3 evenColor;
  vec3 oddColor;
};

vec3 textureValue(Texture texture, float u, float v, vec3 point);

struct Ray {
  vec3 origin;
  vec3 dir;
};

vec3 rayAt(Ray ray, float t);

#define MATERIAL_TYPE_LAMBEERTIAN 0
#define MATERIAL_TYPE_METAL 1
#define MATERIAL_TYPE_DIELECTRIC 2

struct Material {
  int type;
  vec3 albedo;
  float fuzz;
  float ir;
  bool textured;
  Texture texture;
};

struct HitRecord {
  vec3 point;
  vec3 normal;
  float t;
  bool frontFace;
  Material material;
  float u;
  float v;
};

void hitRecordSetFaceNormal(inout HitRecord hitRecord, Ray ray,
                            vec3 outwardNormal);

float reflectance(float cosine, float refIdx);
bool materialScatter(Material material, Ray ray, HitRecord record,
                     inout vec3 attenuation, inout Ray scattered);

struct Interval {
  float min;
  float max;
};

bool intervalContains(Interval interval, float x);
bool intervalSurrounds(Interval interval, float x);
float intervalClamp(Interval interval, float x);

struct Sphere {
  vec3 center;
  float radius;
  Material material;
};

bool sphereHit(Sphere sphere, Ray ray, Interval interval,
               inout HitRecord hitRecord);
void sphereGetUV(vec3 point, inout float u, inout float v);

float lengthSquared(vec3 vector);
float degreesToRadians(float degrees);
float linearToGamma(float linearComponent);
bool nearZero(vec3 vec);

uint stepRNG(uint rngState);
float stepAndOutputRNGFloat(inout uint rngState);
float randomFloat();
float randomFloat(float min, float max);
vec3 randomVector();
vec3 randomVector(float min, float max);
vec3 randomInUnitSphere();
vec3 randomUnitVector();
vec3 randomOnHemisphere(vec3 normal);

bool worldHit(Ray ray, Interval interval, inout HitRecord hitRecord);
vec3 rayColor(Ray ray);

Sphere spheres[NUM_SPHERES];

void main() {
  /* TODO: add camera controller (+ defocus blur) + bvh */
  const vec3 camPos = vec3(0.0);

  int index = 0;
  spheres[index].center = vec3(0, 0, -1);
  spheres[index].radius = 0.5;
  spheres[index].material.type = MATERIAL_TYPE_LAMBEERTIAN;
  spheres[index].material.albedo = vec3(0.1, 0.2, 0.5);
  spheres[index].material.textured = false;

  index = 1;
  spheres[index].center = vec3(0, -100.5, -1);
  spheres[index].radius = 100;
  spheres[index].material.type = MATERIAL_TYPE_LAMBEERTIAN;
  spheres[index].material.albedo = vec3(0.8, 0.8, 0.0);
  spheres[index].material.textured = true;
  spheres[index].material.texture.type = TEXTURE_TYPE_CHECKER;
  spheres[index].material.texture.invScale = 1.0 / 0.32;
  spheres[index].material.texture.evenColor = vec3(0.2, 0.3, 0.1);
  spheres[index].material.texture.oddColor = vec3(0.9, 0.9, 0.9);

  index = 2;
  spheres[index].center = vec3(-1, 0, -1);
  spheres[index].radius = 0.5;
  spheres[index].material.type = MATERIAL_TYPE_DIELECTRIC;
  spheres[index].material.ir = 1.5;

  index = 3;
  spheres[index].center = vec3(1, 0, -1);
  spheres[index].radius = 0.5;
  spheres[index].material.type = MATERIAL_TYPE_METAL;
  spheres[index].material.albedo = vec3(0.8, 0.6, 0.2);
  spheres[index].material.fuzz = 0.0;

  ivec2 imageSize = imageSize(resultImage);
  vec2 uv = vec2(gl_GlobalInvocationID.xy) / imageSize;

  float aspectRatio = float(imageSize.x) / float(imageSize.y);

  vec3 pixelColor = vec3(0.0);
  for (int i = 0; i < NUM_SAMPLES; ++i) {
    float px = randomFloat(-ANTI_ALIASING_FORCE, ANTI_ALIASING_FORCE);
    float py = randomFloat(-ANTI_ALIASING_FORCE, ANTI_ALIASING_FORCE);
    vec2 sampleSquare = (px * vec2(uv.x, 0.0)) + (py * vec2(0.0, uv.y));

    Ray ray = {camPos, normalize(vec3((-1.0 + 2.0 * (uv + sampleSquare)) *
                                          vec2(aspectRatio, 1.0),
                                      -1.0))};

    pixelColor += rayColor(ray);
  }

  pixelColor *= 1.0 / NUM_SAMPLES;
  pixelColor.x = linearToGamma(pixelColor.x);
  pixelColor.y = linearToGamma(pixelColor.y);
  pixelColor.z = linearToGamma(pixelColor.z);

  imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy),
             vec4(pixelColor, 1.0));
}

vec3 textureValue(Texture texture, float u, float v, vec3 point) {
  switch (texture.type) {
  case TEXTURE_TYPE_SOLID: {
    return texture.color;
  } break;
  case TEXTURE_TYPE_CHECKER: {
    int xInt = int(floor(texture.invScale * point.x));
    int yInt = int(floor(texture.invScale * point.y));
    int zInt = int(floor(texture.invScale * point.z));

    bool isEven = (xInt + yInt + zInt) % 2 == 0;

    return isEven ? texture.evenColor : texture.oddColor;

  } break;
  default: {
    return vec3(0.0);
  } break;
  }

  return vec3(0.0);
}

vec3 rayAt(Ray ray, float t) { return ray.origin + t * ray.dir; }

void hitRecordSetFaceNormal(inout HitRecord hitRecord, Ray ray,
                            vec3 outwardNormal) {
  hitRecord.frontFace = dot(ray.dir, outwardNormal) < 0;
  hitRecord.normal = hitRecord.frontFace ? outwardNormal : -outwardNormal;
}

float reflectance(float cosine, float refIdx) {
  float r0 = (1 - refIdx) / (1 + refIdx);
  r0 = r0 * r0;

  return r0 + (1 - r0) * pow(1 - cosine, 5);
}

bool materialScatter(Material material, Ray ray, HitRecord record,
                     inout vec3 attenuation, inout Ray scattered) {
  switch (material.type) {
  case MATERIAL_TYPE_LAMBEERTIAN: {
    vec3 scatterDirection = record.normal + randomUnitVector();
    if (nearZero(scatterDirection)) {
      scatterDirection = record.normal;
    }
    scattered.origin = record.point;
    scattered.dir = scatterDirection;
    if (material.textured) {
      attenuation =
          textureValue(material.texture, record.u, record.v, record.point);
    } else {
      attenuation = material.albedo;
    }

    return true;
  } break;
  case MATERIAL_TYPE_METAL: {
    vec3 reflected = reflect(normalize(ray.dir), record.normal);
    scattered.origin = record.point;
    scattered.dir = reflected + material.fuzz * randomUnitVector();
    attenuation = material.albedo;

    return dot(scattered.dir, record.normal) > 0;
  } break;
  case MATERIAL_TYPE_DIELECTRIC: {
    attenuation = vec3(1.0);
    float refractionRatio =
        record.frontFace ? (1.0 / material.ir) : material.ir;

    vec3 unitDirection = normalize(ray.dir);
    float cosTheta = min(dot(-unitDirection, record.normal), 1.0);
    float sinTheta = sqrt(1.0 - (cosTheta * cosTheta));

    bool cannotRefract = (refractionRatio * sinTheta) > 1.0;
    vec3 direction;
    if (cannotRefract ||
        reflectance(cosTheta, refractionRatio) > randomFloat()) {
      direction = reflect(unitDirection, record.normal);
    } else {
      direction = refract(unitDirection, record.normal, refractionRatio);
    }

    scattered.origin = record.point;
    scattered.dir = direction;

    return true;
  } break;
  default: {
    return false;
  } break;
  }

  return false;
}

bool intervalContains(Interval interval, float x) {
  return interval.min <= x && x <= interval.max;
}

bool intervalSurrounds(Interval interval, float x) {
  return interval.min < x && x < interval.max;
}

float intervalClamp(Interval interval, float x) {
  return clamp(x, interval.min, interval.max);
}

bool sphereHit(Sphere sphere, Ray ray, Interval interval,
               inout HitRecord hitRecord) {
  vec3 oc = ray.origin - sphere.center;
  float a = dot(ray.dir, ray.dir);
  float halfB = dot(oc, ray.dir);
  float c = dot(oc, oc) - sphere.radius * sphere.radius;

  float discriminant = halfB * halfB - a * c;
  if (discriminant < 0.0) {
    return false;
  }

  float sqrtd = sqrt(discriminant);

  float root = (-halfB - sqrtd) / a;
  if (!intervalSurrounds(interval, root)) {
    root = (-halfB + sqrtd) / a;
    if (!intervalSurrounds(interval, root)) {
      return false;
    }
  }

  hitRecord.t = root;
  hitRecord.point = rayAt(ray, hitRecord.t);
  vec3 outwardNormal = (hitRecord.point - sphere.center) / sphere.radius;
  sphereGetUV(outwardNormal, hitRecord.u, hitRecord.v);
  hitRecordSetFaceNormal(hitRecord, ray, outwardNormal);
  hitRecord.material = sphere.material;

  return true;
}

void sphereGetUV(vec3 point, inout float u, inout float v) {
  float theta = acos(-point.y);
  float phi = atan(point.x, -point.z) + PI;

  u = phi / (2 * PI);
  v = theta / PI;
}

float lengthSquared(vec3 vector) {
  return vector.x * vector.x + vector.y * vector.y + vector.z * vector.z;
}

float degreesToRadians(float degrees) { return degrees * PI / 180.0; }

float linearToGamma(float linearComponent) { return sqrt(linearComponent); }

bool nearZero(vec3 vec) {
  float s = 1e-8;
  return abs(vec.x) < s && abs(vec.y) < s && abs(vec.z) < s;
}

uint stepRNG(uint rngState) { return rngState * 747796405 + 1; }

float stepAndOutputRNGFloat(inout uint rngState) {
  rngState = stepRNG(rngState);
  uint word = ((rngState >> ((rngState >> 28) + 4)) ^ rngState) * 277803737;
  word = (word >> 22) ^ word;
  return float(word) / 4294967295.0f;
}

float randomFloat() { return stepAndOutputRNGFloat(rngState); }

float randomFloat(float min, float max) {
  return min + (max - min) * randomFloat();
}

vec3 randomVector() {
  return vec3(randomFloat(), randomFloat(), randomFloat());
}

vec3 randomVector(float min, float max) {
  return vec3(randomFloat(min, max), randomFloat(min, max),
              randomFloat(min, max));
}

vec3 randomInUnitSphere() {
  while (true) {
    vec3 point = randomVector(-1, 1);
    if (lengthSquared(point) < 1) {
      return point;
    }
  }

  return vec3(0.0);
}

vec3 randomUnitVector() { return normalize(randomInUnitSphere()); }

vec3 randomOnHemisphere(vec3 normal) {
  vec3 onUnitSphere = randomUnitVector();
  int multiplier = int(dot(onUnitSphere, normal) > 0.0) * 2 - 1;

  return onUnitSphere * multiplier;
}

bool worldHit(Ray ray, Interval interval, inout HitRecord hitRecord) {
  HitRecord tempRecord;
  bool hitAnything = false;
  float closestSoFar = interval.max;

  for (int i = 0; i < NUM_SPHERES; ++i) {
    Interval tempInterval = {interval.min, closestSoFar};
    if (sphereHit(spheres[i], ray, tempInterval, tempRecord)) {
      hitAnything = true;
      closestSoFar = tempRecord.t;
      hitRecord = tempRecord;
    }
  }

  return hitAnything;
}

vec3 rayColor(Ray ray) {
  vec3 result = vec3(1.0);
  Interval interval = {0.001, FLT_MAX};
  Ray currentRay = ray;
  HitRecord record;

  for (int i = 0; i < NUM_BOUNCES; ++i) {
    if (worldHit(currentRay, interval, record)) {
      Ray scattered;
      vec3 attenuation;

      if (materialScatter(record.material, ray, record, attenuation,
                          scattered)) {
        result *= attenuation;
        currentRay = scattered;
      } else {
        return vec3(0.0);
      }

    } else {
      vec3 unitDirection = normalize(currentRay.dir);
      float a = 0.5 * (unitDirection.y + 1.0);
      return result *
             vec3((1.0 - a) * vec3(1.0, 1.0, 1.0) + a * vec3(0.5, 0.7, 1.0));
    }
  }

  return vec3(0.0);
}